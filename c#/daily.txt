2017.12.6:
LuaJIT分为JIT模式和Interpreter模式
1.JIT模式：在iOS下是无法开启，比原生Lua 极限可以达几十倍
2.Interpreter模式：比原生Lua平均可以快3~8倍，编译成中间态的字节码（bytecode），然后每执行下一条字节码指令 (需LuaJIT支持的平台，可以手动关闭JIT，强制运行在Interpreter模式下)
(这个模式不需要运行时生成可执行机器码（字节码是不需要申请可执行内存空间的），所以任何平台任何时候都能用
Interpreter模式下执行可能将经常执行的代码JIT化（运行过程中决定的，安卓下可能JIT失败），优化成固定的内存访问
如果安卓下未关闭JIT，LuaJIT会重复尝试JIT(即编译出机器码放到特定的内存空间)，但是arm有一个限制，就是跳转指令只能跳转前后32MB的空间，这导致了一个巨大的问题：LuaJIT生成的代码要保证在一个连续的64MB空间内，如果这个空间被其他东西占用了，LuaJIT就会分配不出用于jit的内存，但LuaJIT会重复尝试导致性能处于瘫痪的状态(这时要关闭JIT)。
应对方案：
1.在android工程的Activity入口中就加载LuaJIT，做好内存分配，然后将这个luasate传递给Unity使用
2.寄存器分配失败->减少local变量、避免过深的调用层次
3.JIT遇到不支持的字节码->少用for in pairs，少用字符串连接
(关闭JIT:tolua首句修改 if jit then jit.off(); jit.flush() end)

luac:
Lua编译器,把用Lua语言编写的程序翻译为二进制文件
预编译单元（chunk）的主要优势在于:加载更快,预编译并非意味着执行更快速，因为Lua中的单元总会在执行前被编译为字节码

2017.12.12
Application.streamingAssetsPath 只能用AssetBundle.LoadFromFile 。如果想用File类操作。 比如File.ReadAllText  或者 File.Exists  Directory.Exists 这样都是不行的。

2017.12.14  LZMA，LZ4和不压缩(三种资源包的压缩方式)
AssetBundle.LoadFromFile不能加载压缩过的AssetBundle(不压缩、LZ4),同步创建AssetBundle对象，这是最快的创建方式。创建完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.Load需要通过IO从磁盘中获取(同LoadFromCacheOrDownload解压到外部硬盘)

当使用LZMA压缩时，为什么加载后还要进行LZ4 compression？其实AssetBundle的原则是这样的：
如果可以直接读取包中的资源(不压缩、LZ4)：
如果包在磁盘中，不用把包读取到unity内存，只读取资源信息索引就行了。
如果包在网络或mono内存中，那就把包读取到unity内存中。
如果不可以直接读取包中的资源(LZMA)：就要先解压，然后压缩成LZ4保存在内存中，供以后取用。

结论：打包使用DeterministicAssetBundle+UncompressedAssetBundle,对bundle进一步压缩http://blog.csdn.net/y1196645376/article/details/52492294），再使用AssetBundle.LoadFromFile加载bundle（推荐方式），如果用www加载要注意不要缓存www,要释放www,只保留assetbundle

2017.12.15
python 使用git命令必需配置 git 环境
sys.path[0] .py文件所在路径

2017.12.18
lua 对于弱引用table，其实有三种形式：
1）key值弱引用，也就是刚刚说到的情况，只要其他地方没有对key值引用，那么，table自身的这个字段也会被删除。设置方法：setmetatable(t, {__mode = “k”});
2）value值弱引用，情况类似，只要其他地方没有对value值引用，那么，table的这个value所在的字段也会被删除。设置方法：setmetatable(t, {__mode = “v”});
3）key和value弱引用，规则一样，但是key和value都同时生效，任意一个起作用时都会导致table的字段被删除。设置方法：setmetatable(t, {__mode = “kv”});

2017.12.19
lua: module("filename", package.seeall)函数 5.2版本开始不推荐，原因：
1.package.seeall 这种方式破坏了模块的高内聚，原本引入 "filename" 模块只想调用它的 foobar() 函数，但是它却可以读写全局属性，例如 "filename.os"。
2.module 函数压栈操作引发的副作用，污染了全局环境变量。例如 module("filename") 会创建一个 filename 的 table，并将这个 table 注入全局环境变量中，这样使得没有引用它的文件也能调用 filename 模块的方法。

lua5.1版本使用 __gc ：table 被回收时会触发的回调，可以用来做一些 lua内存泄露 及 资源释放 等操作

2017.12.20
两个table同时弱引用一个对象，但这个对象被nil后collectgarbage，两个table都会销毁对该对象的引用，但是如果有一个table不是弱引用，那么另外一个也是会记录该对象

2017.12.26
正则表达式复习

2018.1.2
Capacity属性：可包含在当前实例所分配的内存中的最大字符数
StringBuilder 类Capacity属性的默认值为16，当StringBuilder 对象的Length属性值超过Capacity属性的长度时，StringBuilder 对象内部会重新构造一个字符数组
当StringBuilder 对象的Length属性超过Capacity的2倍时，不管有没有设置过Capacity属性的值，最终Capacity属性会和Length属性相同。
*重新扩充构造内部的字符数组，影响性能，所以在构造StringBuilder对象时，最好先预估下追加字符串的总长度，根据这个总长度，在StringBuilder构造函数中设置一下Capacity参数

2018.1.3
Canvas group 场景界面过渡效果
ScriptableObject:自定义资源（.asset）配置数据

#if UNITY_EDITOR
// 加载资源
Texture2D image = AssetDatabase.LoadAssetAtPath("Assets/Images/1.jpg", typeof(Texture2D)) as Texture2D; //不使用ab模式使用该方法加载资源
Resources.UnloadAsset(image);  //只是标记该资源需要被GC回收，但不是立刻就被回收的

// 通知编辑器有资源被修改了
EditorUtility.SetDirty(mat);
// 保存所有修改 ,
AssetDatabase.SaveAssets();

// 以mat为模板创建mat2
Material mat2 = Object.Instantiate<Material>(mat);
// 创建资源
AssetDatabase.CreateAsset(mat2, "Assets/Materials/1.mat");
// 刷新编辑器，使刚创建的资源立刻被导入，才能接下来立刻使用上该资源
AssetDatabase.Refresh();
#endif

unity-spine 骨胳动画

2018.1.5
1.加载AssetBundle，先试着检查是否有缓存引用加1，这样就避免可能因为这时候有依赖身份但加载过程中因为没引用而被卸载掉
2.加载bundle，如果有依赖的先加载依赖，如果事异步的则先放进加载队列（但是还是有可能该bundle先于依赖加载完就有问题了？方案:记录所有依赖，开始加载前判断是否所有的依赖加载完）
3.依赖加载方式跟改bundle加载方式一样