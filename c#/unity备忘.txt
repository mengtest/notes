unity 渲染顺序:
1.Canvas 以overlay模式的渲染最上面，如果两个一样overlay的Canvas，谁的Sort Order大，谁渲染上面，Sort Order一样大的看谁先加载
2.Canvas 以Camera模式:不同Camera的Depth(大的渲染最上面,一样大的先加载先渲染),同Camera的soringLayer(大的渲染最上面),同sortingLayer下面的 order in layer(大的渲染最上面)
 
所有的Component，都会指向其所属的GameObject
this.renderer ， this.transform ，this.gameObject

（在场景中用find找不到该物体）
this.gameObject.SetActive(false);// ! use this to write
this.gameObject.activeSelf = false;//物体本身的active状态
this.gameObject.activeInHierarchy = false;//这个物体及其所有父物体(及祖先物体)的activeself状态都为true该值为true，可见。

this.renderer.enabled = false;//是控制一个物体是否在屏幕上渲染或显示，而物体实际还是存在，只是相当于隐身，而物体本身的碰撞体还依然存在的。
this.collider.enabled = false;//无效化碰撞器

如果想实现两个刚体物理的实际碰撞效果时候用OnCollisionEnter，Unity引擎会自动处理刚体碰撞的效果。
如果想在两个物体碰撞后自己处理碰撞事件用OnTriggerEnter。
OnTriggerEnter必须有一个物体具有刚体

OnCollisionEnter方法必须是在两个碰撞物体都不勾选isTrigger的前提下才能进入，反之只要勾选一个isTrigger那么就能进入OnTriggerEnter方法。
OnCollisionEnter和OnTriggerEnter是冲突的不能同时存在的。

[HideInInspector]表示将公有变量显示在面板上的序列化值隐藏起来。
[SerializeField]表示将原本不会被序列化的私有变量和保护变量可以序列化，这么他们在下次读取时，就是你上次赋值的值。
[Range(0, 1)] [SerializeField] private float slider = .37f;

SendMessage 最大的诟病是它的效率问题。使用十分方便，只是不可频繁使用。
*一定要有接收者，否则会报错
gameObject.SendMessage ("ApplyDamage", 5.0);// 所有附属于这个游戏物体的脚本只要有ApplyDamage函数的，都会调用之.
BroadcastMessage  //对物体和所有子物体发送消息。
SendMessageUpwards //向物体和父物体发送消息


**绝不要把父子刚体放在一起。绝不要缩放刚体的父对象。
**不要逐帧移动静态碰撞器，移动静态碰撞器将导致PhysX引擎的内部重置，非常耗费资源
运动学刚体不受物理世界控制，但是可以和其他的非运动学刚体互相作用。
静态碰撞器是一个包含碰撞器但不含刚体的游戏对象（地面）

*角色控制器Character Controller主要用于第三人称游戏主角控制，不使用刚体物理效果
控制器不会对加在它自身上的力做出反应，也不会自动推开其他刚体。
如果想让角色控制器推开其他刚体或者对象，你可以在对象附加的脚本中添加OnControllerColliderHit()函数，这样对它们施加力就能够产生碰撞。
角色关节组建需要物体有附着的刚体组件
*除非被标记为凸起的（Convex），否则网格碰撞器间不会发生碰撞