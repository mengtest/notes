Unity3D提供了一种机制AssetBundle，可以满足所有资源的比对下载加载
对于代码，Unity3D是不提供变更机制的。但是Unity3D执行核心是Mono，也就是dotnet，
dotnet有一种符号反射机制，可以直接加载一个dll，然后反射出其中的类型进行操作。符号和反射的主要问题是有些平台不能使用

更新需要三个模块：
  资源下载模块
当assetbundle不能满足需要时，我们需要自己建立检查更新需要则下载的机制，也就是资源下载模块。
这个资源下载模块应该有一个版本生成工具，我们将一组文件生成一个一个版本待下载。
有一个Unity3D用的下载模块，下载模块会首先检查服务器上的版本信息，和本地信息做比对，需要的文件则下载。

  资源加载模块
然后需要建立自己的从下载保存在本地的文件中加载出资源的机制，也就是资源加载模块。
资源加载模块负责从下载的文件中加载出资源。
如果你希望游戏带有一份初始资源文件，这里有两种思路
一种是资源加载模块直接提供从包内文件和下载文件两种加载路径
一种是游戏第一次启动时，将包内文件全部copy到下载文件

  脚本模块
当符号反射不能满足需求时，业务逻辑更新就只有套用脚本语言这一条路，也就是脚本模块。
虽然dotnet世界里有很多脚本可以用 ironRuby ironPython,可是在unity这个特定环境下全部不可用。
你可以使用的一个选择是lua，这个由魔兽世界采用作为界面脚本，从而红遍整个游戏行业，十年经久不衰的脚本。
unity有了很多lua的绑定库，也有了unilua这样的pure c#移植实现。
你还有一个选择是C#Light/Evil，他是C#语法的，pure c#实现的一门新生脚本语言，就是为了Unity3D逻辑热更新而生。

在Unity环境里内嵌一个Lua虚拟机，经常变动的和对执行效率没要求的逻辑用Lua实现（luajit lua代码解释器）
C#脚本首先会被编译成IL代码，然后再由CLR从内存中读取这些IL代码并将其转化为原生代码，这是.NET程序的运行机制，而Mono是.NET在开源社区中的一种实现，Mono对C#代码的编译分为两种，即即时编译JIT（动态）和提前编译AOT（静态）
IOS并非把JIT（just in time即时编译）禁止是IOS封了内存（或者堆）的可执行权限，相当于封锁了JIT这种编译方式

IOS不能热更新，不是因为不能用反射，是因为
System.Reflection.Assembly.Load 无法使用
System.Reflection.Emit 无法使用
System.CodeDom.Compiler 无法使用
这三个不能用，就把传统dotnet动态路径坑死了
动态载入dll或者cs的方法就这几个, IOS 下不能动态载入dll或者cs 文件（iOS是不允许不通过AppStore更新代码）
=========================================================

尽量只把U3D当一个渲染引擎来看待, 不然你会发现热更资源很悲剧, 资源一定要与逻辑分开, 因为U3D用的是类的序列化, 后期改动会导致前面导出的资源不能用
1.prefab尽量不去绑定脚本，尽量在代码里AddComponent<接口实现脚本>，在实例prefab的GetComponent<接口脚本>.接口操作。但可以绑定那些不会再改动的脚本。