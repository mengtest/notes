Unity3D提供了一种机制AssetBundle，可以满足所有资源的比对下载加载
对于代码，Unity3D是不提供变更机制的。但是Unity3D执行核心是Mono，也就是dotnet，
dotnet有一种符号反射机制，可以直接加载一个dll，然后反射出其中的类型进行操作。符号和反射的主要问题是有些平台不能使用

更新需要三个模块：
  资源下载模块
当assetbundle不能满足需要时，我们需要自己建立检查更新需要则下载的机制，也就是资源下载模块。
这个资源下载模块应该有一个版本生成工具，我们将一组文件生成一个一个版本待下载。
有一个Unity3D用的下载模块，下载模块会首先检查服务器上的版本信息，和本地信息做比对，需要的文件则下载。

  资源加载模块
然后需要建立自己的从下载保存在本地的文件中加载出资源的机制，也就是资源加载模块。
资源加载模块负责从下载的文件中加载出资源。
如果你希望游戏带有一份初始资源文件，这里有两种思路
一种是资源加载模块直接提供从包内文件和下载文件两种加载路径
一种是游戏第一次启动时，将包内文件全部copy到下载文件

  脚本模块
当符号反射不能满足需求时，业务逻辑更新就只有套用脚本语言这一条路，也就是脚本模块。
虽然dotnet世界里有很多脚本可以用 ironRuby ironPython,可是在unity这个特定环境下全部不可用。
你可以使用的一个选择是lua，这个由魔兽世界采用作为界面脚本，从而红遍整个游戏行业，十年经久不衰的脚本。
unity有了很多lua的绑定库，也有了unilua这样的pure c#移植实现。
你还有一个选择是C#Light/Evil，他是C#语法的，pure c#实现的一门新生脚本语言，就是为了Unity3D逻辑热更新而生。


IOS不能热更新，不是因为不能用反射，是因为
System.Reflection.Assembly.Load 无法使用
System.Reflection.Emit 无法使用
System.CodeDom.Compiler 无法使用
这三个不能用，就把传统dotnet动态路径坑死了
为啥“这三个不能用，就把传统dotnet动态路径坑死了”呢
动态载入dll或者cs的方法就这几个, IOS 下不能动态载入dll或者cs 文件，已经编译进去的没事。
=========================================================

尽量只把U3D当一个渲染引擎来看待, 不然你会发现热更资源很悲剧, 资源一定要与逻辑分开, 因为U3D用的是类的序列化, 后期改动会导致前面导出的资源不能用。就和开发AS3游戏差不多了。可以这么理解
1.prefab尽量不去绑定脚本，尽量在代码里AddComponent<接口实现脚本>，在实例prefab的GetComponent<接口脚本>.接口操作。
2.prefab可以绑定那些不会再改动的脚本。