值类型: 枚举，数值，结构体，布尔
引用类型：string,数组，object

装箱：值类型转换为对象类型时
拆箱：一个对象类型转换为值类型

值类型是在栈中分配内存，它们有自身的生命周期，所以不用对它们进行管理，会自动分配和释放。
而引用类型是在堆中分配内存的。所以它的分配和释放就需要像回收机制来管理。

C#代码通过C#编译器编译成程序集，程序集由微软中间语言组成，CLR会为程序集开辟一个应用程序域，程序集就是运行在这个应用程序域里面的。
托管代码:被CLR管理的代码。
非托管代码：不被CLR管理的代码。

分配在栈空间的变量，一旦执行完成其所在的作用域（即大括号范围）就会被CLR回收。释放内存
分配在堆里面的对象，当没有任何变量引用它的时候，这个对象就被标记为“垃圾对象”，等待垃圾回收器回收。

GC会定时清理堆里面的垃圾对象，GC的清理频率程序员无法决定，CLR会自动控制。当一个对象标记为垃圾的时候，这个对象不一定会被立即回收。

当堆里面的对象有1W个的时候，GC是不是循环1W次来判断是否为“垃圾对象”，然后对其进行回收呢？答案是否定的，
堆里面总共有3代，当程序运行时，有对象需要存储在堆里面，GC就会创建第1代（假设空间大小为256K），
对象就会存储在第0代里面，当程序继续运行，运行到第0代的大小不足以存放对象，这时候就就会创建第1代（假设空间为10M），
GC就会把第0代里面的“垃圾对象”清理掉，把“活着”的对象放在第1代，这时候第0代就空了，用于存放新来的对象，
当第0代满了的时候，就会继续执行以上操作，随着程序的运行，第1代不能满足存放要求，这时候就会创建第2代，

GC.GetGeneration(P)得到指定的对象对应的代,总共有三代。
GC.Collect();//让垃圾回收器对所有的代进行回收。
GC.Collect(1)//回收第0代和第1代回收。

try
{
   int result = 10/ 0; // 引起异常的语句
}
catch (Exception e)
{
    // 错误处理代码
    Console.WriteLine("Exception caught: {0}", e);
    Throw e；//抛出异常
}
finally
{
    result = 1；// 要执行的语句
}

assert(expression ) 频繁的调用会极大的影响程序的性能，增加额外的开销
assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，
然后通过调用 abort 来终止程序运行。不为0，则继续执行后面的语句