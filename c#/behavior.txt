游戏中的AI角色，可以认为它们一直处于感知（SENSE）->思考（think）->行动（Act）的循环中

OnAwake -> OnStart -> OnUpdate -> OnEnd -> OnBehaviorComplete（Task脚本）
一个 task 就是一个行为，状态：running(子任务执行中).success(所有子任务执行完并成功).fail(子任务或自身失败，后面任务不执行)
1.Composities（复合节点）
2.Decorators（装饰节点）
3.Actions（行为节点）

task是基于行为树，树的每个节点就是个task
gameobject可同时绑定多个行为树
行为树切换：
1.GetComponents<BehaviorTree>();  通过 bt.Group 和 bt.name来区分不同行为树
2.BehaviorManager.instance.IsBehaviorEnabled(bt); bt.EnableBehavior();

Behavior标签：
设置行为树基本信息
ExternalBehavior：编辑好行为树后可以导成asset文件（使用二进制，在preferences设置），可以指定用其他编辑好的行为数，设为none则使用本身编辑中的
Restart When Complete，如果勾选了，则行为树遍历完后会再重新启动一次，不断循环

Inspector标签：
每个task信息

Variables标签：
可以给行为树添加变量，这些变量可以通过GetVariable跟SetVariableValue来读取和赋值，并可以在各种Task节点里进行传递和赋值

导成二进制文件（一个xxxx.asset文件，它是作为ExternalBehaviorTree存储的）动态添加行为树：
var bt = gameObject.AddComponent<BehaviorTree> ();  
var extBt = Resources.Load<ExternalBehaviorTree> ("Behavior");  
bt.StartWhenEnabled = false;  
bt.ExternalBehavior = extBt;  
bt.EnableBehavior ();  

idle:停止 wait:等待多少秒
sequece:子任务顺序执行从左到右 （and）
selector:子任务顺序执行从左到右,遇到有一个子任务成功就自身成功，后面子任务不执行了（or）

AbortType:
0.none 执行一次
1.lower priority 可以打断低优先级的同级任务当自身true（循环判断）
2.self 可以打断自身当自身fail（循环判断直到自身fail）
3.both 上面两个结合

Shared类型:该行为数的全局变量，不同task可以共享变量

patrol：巡逻，按指定路线点先找到最近的点为第一目标点，然后顺序循环下面的路线点，没导航路线了顺序下去