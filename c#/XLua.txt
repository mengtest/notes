LuaEnv的使用建议：全局就一个实例，并在Update中调用GC方法，完全不需要时调用Dispose
void Tick()
清除Lua的未手动释放的LuaBase（比如，LuaTable， LuaFunction），以及其它一些事情。
在Update中需要定期调用（1s）。

DoString("require 'byfile'") //DoString("xxx"),默认加载的放在 Global 环境下，后加载的会替换之前的
require实际上是调一个个的loader去加载，有一个成功就不再往下尝试，全失败则报文件找不到
放Resources下的lua文件得加上txt后缀
建议的加载Lua脚本方式是：整个程序就一个DoString("require 'main'")，然后在main.lua加载其它脚本

luaenv.AddLoader((ref string filename) => {
   if (filename == "InMemory")
   {
      string script = "return {pram = 9999}";
      return System.Text.Encoding.UTF8.GetBytes(script);
   }
   return null;
});
luaenv.DoString("print('InMemory.ccc=', require('InMemory').pram)");

LuaTable: （参考c# LuaBehaviour）
TextAsset luaScript; //脚本txt文件
LuaTable scriptEnv;  //脚本代码块，将上面文本赋值给该变量，不用一定要 Dispose
Action luaStart; //引用 lua里的start函数 ，不用一定要 Dispose

LuaTable meta = luaEnv.NewTable();
meta.Set("__index", luaEnv.Global);
scriptEnv.SetMetaTable(meta);
meta.Dispose();  

scriptEnv.Set("self", this); //Set(name,object) 对lua 脚本变量赋值
foreach (var injection in injections)
{
  //传GameObject input:GetComponent("InputField").text
  scriptEnv.Set(injection.name, injection.value);
}

luaEnv.DoString(luaScript.text, "LuaBehaviour", scriptEnv); //scriptEnv 赋值代码块

Action luaAwake = scriptEnv.Get<Action>("awake"); //可以指定返回类型
scriptEnv.Get("start", out luaStart);   //获取 lua 函数（local 类型的不能获取到） 在该脚本里调用


C#访问Lua：
一、获取一个全局基本数据类型
luaenv.Global.Get<int>("a")

二、访问一个全局的table
1.轻量级的by value方式：映射到Dictionary<>，List<>
不想定义class或者interface的话，可以考虑用这个，前提table下key和value的类型都是一致的。

2.//映射到有对应字段的class,table的属性可以多于或者少于class的属性, by value
DClass d = luaenv.Global.Get<DClass>("t");

3.//建议用法 映射到interface实例，要求interface加到生成列表，否则会返回null, by ref,依赖于生成代码
ItfD d3 = luaenv.Global.Get<ItfD>("t");

4、另外一种by ref方式：映射到LuaTable类,没有类型检查,慢
LuaTable d4 = luaenv.Global.Get<LuaTable>("t");

三、访问一个全局的function
1、映射到delegate,建议的方式，性能好很多，而且类型安全。缺点是要生成代码
lua的多返回值映射：从左往右映射到c#的输出参数，输出参数包括返回值，out参数，ref参数

2.映射到LuaFunction,优缺点刚好和上面相反
LuaFunction上有个变参的Call函数，可以传任意类型任意个数的参数，返回值是object的数组，对应于lua的多返回值


Lua调用C# 静态方法用. 类成员方法用：
local newGameObj = CS.UnityEngine.GameObject()
CS.UnityEngine.Time.timeScale = 0.5
local GameObject = CS.UnityEngine.GameObject
GameObject.Find('helloworld')

obj.TestDelegate = lua_delegate + testobj.TestDelegate
obj.TestDelegate = testobj.TestDelegate - lua_delegate

obj:TestEvent('+', lua_event_callback1)
obj:TestEvent('-', lua_event_callback1)

newGameObj:AddComponent(typeof(CS.UnityEngine.ParticleSystem))
obj:GetComponent("InputField")